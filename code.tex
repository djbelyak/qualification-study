\appendix

\chapter{Исходный код нейросетевой аппроксимации}

\begin{lstlisting}
    from __future__ import absolute_import
    from __future__ import division
    from __future__ import print_function
    
    import itertools
    
    import pandas as pd
    import numpy as np
    import tensorflow as tf
    import matplotlib.pyplot as plt
    
    tf.logging.set_verbosity(tf.logging.INFO)
    
    COLUMNS = ['1-1', '1-2', '1-3', '1-4', '10-1', '10-2', '10-3', '10-4', '10-5', '10-6', '10-7', '11-1', '11-2', '11-3', '11-4', '2-1', '2-2', '2-3', '2-4', '2-5', '2-6', '2-7', '3-1', '3-2', '3-3', '3-4', '3-5', '3-6', '3-7', '3-8', '4-1', '4-2', '4-3', '4-4', '4-5', '4-6', '4-7', '4-8', '4-9', '5-1', '5-10', '5-2', '5-3', '5-4', '5-5', '5-6', '5-7', '5-8', '5-9', '6-1', '6-2', '6-3', '6-4', '6-5', '6-6', '6-7', '6-8', '6-9', '7-1', '7-10', '7-2', '7-3', '7-4', '7-5', '7-6', '7-7', '7-8', '7-9', '8-1', '8-2', '8-3', '8-4', '8-5', '8-6', '8-7', '8-8', '8-9', '9-1', '9-2', '9-3', '9-4', '9-5', '9-6', '9-7', '9-8', 'AP', 'PP1', 'PP2', 'PP3', 'ro']
    FEATURES = ['1-1', '1-2', '1-3', '1-4', '10-1', '10-2', '10-3', '10-4', '10-5', '10-6', '10-7', '11-1', '11-2', '11-3', '11-4', '2-1', '2-2', '2-3', '2-4', '2-5', '2-6', '2-7', '3-1', '3-2', '3-3', '3-4', '3-5', '3-6', '3-7', '3-8', '4-1', '4-2', '4-3', '4-4', '4-5', '4-6', '4-7', '4-8', '4-9', '5-1', '5-10', '5-2', '5-3', '5-4', '5-5', '5-6', '5-7', '5-8', '5-9', '6-1', '6-2', '6-3', '6-4', '6-5', '6-6', '6-7', '6-8', '6-9', '7-1', '7-10', '7-2', '7-3', '7-4', '7-5', '7-6', '7-7', '7-8', '7-9', '8-1', '8-2', '8-3', '8-4', '8-5', '8-6', '8-7', '8-8', '8-9', '9-1', '9-2', '9-3', '9-4', '9-5', '9-6', '9-7', '9-8', 'AP', 'PP1', 'PP2', 'PP3']
    LABEL = 'ro'
    
    #training_set = pd.read_csv("wwrc_data/real_data.csv", skipinitialspace=True,
    #                           skiprows=1, names=COLUMNS)
    #test_set = pd.read_csv("wwrc_data/real_data.csv", skipinitialspace=True,
    #                       skiprows=1, names=COLUMNS)
    prediction_set = pd.read_csv("wwrc_data/real_data.csv", skipinitialspace=True,
                                 skiprows=1, names=COLUMNS)
    training_set = prediction_set.head(int(prediction_set.size*0.75))
    test_set = prediction_set.tail(int(prediction_set.size*0.25))
    
    feature_cols = [tf.contrib.layers.real_valued_column(k) for k in FEATURES]
    
    regressor = tf.contrib.learn.DNNRegressor(feature_columns=feature_cols,
                                              hidden_units=[50, 10],
                                              model_dir="real_model")
    
    def input_fn(data_set):
      feature_cols = {k: tf.constant(data_set[k].values)
                      for k in FEATURES}
      labels = tf.constant(data_set[LABEL].values)
      return feature_cols, labels
    
    def train_input_fn():
      return input_fn(training_set)
    
    def eval_input_fn():
      return input_fn(test_set)
    
    
    regressor.fit(input_fn=lambda: input_fn(training_set), steps=50000)
    
    ev = regressor.evaluate(input_fn=lambda: input_fn(test_set), steps=1)
    
    loss_score = ev["loss"]
    print("Loss: {0:f}".format(loss_score))
    
    y = regressor.predict(input_fn=lambda: input_fn(prediction_set))
    # .predict() returns an iterator; convert to a list and print predictions
    predictions = list(itertools.islice(y, int(prediction_set.size)))
    
    print ("Predictions: {}".format(str(predictions)))
    
    y_target = prediction_set[LABEL].values
    y_pred = np.array(predictions)
    
    print("Diffs:", y_target-y_pred)
    print("Max relative error: ",
              np.amax(np.abs(100*(y_target-y_pred)/y_target)), "%")
    
    print("Mean relative error: ",
              np.mean(np.abs(100*(y_target-y_pred)/y_target)), "%")
    
    print("Max absolute error: ",
              np.amax(np.abs(y_target-y_pred)))
    
    print("Min absolute error: ",
              np.amin(np.abs(y_target-y_pred)))
    
    sigma = np.sqrt(np.sum(y_target-y_pred)*np.sum(y_target-y_pred) /
                        (len(y_target)-1))
    print("Sigma: ", 2*sigma)
    
    x = np.arange(1, y_target.shape[0]+1, 1)
    plt.figure(figsize=(12, 8))
    plt.errorbar(x, y_pred, color='black',
                 yerr=sigma*2, label=u'Output')
    plt.plot(x, y_target, color='green', label=u'Source value', marker='o')
    plt.xlabel(u'Number of company')
    plt.ylabel(r'$\rho$')
    plt.legend()
    plt.grid(True)
    plt.savefig('graph.png')

\end{lstlisting}